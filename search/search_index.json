{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Sample and guideline of how to do authentication and authorization in FHI. The code and samples is built on top of Duende open source project and Microsoft authentication libraries</p> <p>Note: Sample code is not production code. The code should be customized to fit the need of the application.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Check out guide and samples to see how to:</p> <ul> <li>Token Expiry Handling with Downstream APIs</li> <li>Require authentication by default in .NET Core</li> </ul>"},{"location":"packages/","title":"Overview of packages","text":"Package Purpose Releases Fhi.Authentication.Extensions Extension to authentication Releases Fhi.Authorization.Extensions Extensions to authorization and access control Releases"},{"location":"developer-guideline/protecting-endpoints/","title":"Require authentication by default in .NET Core","text":"<p>To require authentication by default on all incoming requests, configure a fallback authorization policy in your application's service pipeline. The policy will automatically require users to be authenticated for all endpoints unless explicitly overridden to allow anonymous access. This approach reduces the risk of accidentally exposing sensitive endpoints.</p> <p>Code samples:</p> <ul> <li>Angular BFF sample</li> <li>Web Api</li> </ul>"},{"location":"developer-guideline/protecting-endpoints/#1-add-the-fallback-policy","title":"1: Add the fallback policy","text":"<p>All controllers and endpoints require an authenticated user. If a request is made to any endpoint and the user is not authenticated, a 401 Unauthorized response is returned. This is achieved using the <code>SetFallbackPolicy</code> method or <code>FallbackPolicy</code> option in the authorization configuration:</p> <pre><code>// Option 1: by default\nbuilder.Services.AddAuthorizationBuilder()\n    .SetFallbackPolicy(new AuthorizationPolicyBuilder()\n        .RequireAuthenticatedUser()\n        .Build());\n\n// Or option 2:\nbuilder.Services.AddAuthorization(options =&gt;\n{\n    options.FallbackPolicy = new AuthorizationPolicyBuilder()\n                .RequireAuthenticatedUser()\n                .Build();\n\n// Or option 3: for multiple authentication schemes\nbuilder.Services.AddAuthorizationBuilder()\n                .SetFallbackPolicy(new AuthorizationPolicyBuilder()\n                            .RequireAuthenticatedUser()\n                            .Build())\n                .AddPolicy(\"Scheme1\", policy =&gt;\n                {\n                    policy.AuthenticationSchemes.Add(\"Scheme1\");\n                    policy.RequireAuthenticatedUser();\n                })\n                 .AddPolicy(\"Scheme2\", policy =&gt;\n                 {\n                     policy.AuthenticationSchemes.Add(\"Scheme2\");\n                     policy.RequireAuthenticatedUser();\n                 });\n\n});\n</code></pre>"},{"location":"developer-guideline/protecting-endpoints/#2-permit-anonymous-access","title":"2: Permit anonymous access","text":"<p>To allow anonymous access to specific endpoints (such as /login, /session, or the SPA fallback) use <code>[AllowAnonymous]</code> or <code>AllowAnonymous()</code> attribute on specific endpoints to permit anonymous access.</p> <pre><code>// This endpoint allows anonymous access\napp.MapGet(\"/login\", [AllowAnonymous] async (HttpContext context) =&gt; { ... });\n\n// For an SPA client like Angular should allow anonymous access to the index page\napp.MapFallbackToFile(\"/index.html\").AllowAnonymous();\n\n</code></pre>"},{"location":"developer-guideline/token-expiry-downstream-api/","title":"Token Expiry Handling with Downstream APIs","text":"<p>For applications that handle authentication on the server using cookies and OpenID Connect (OIDC), and that need to call downstream APIs requiring an access_token or DPoP token, it's important to understand that authentication cookies and tokens have separate lifetimes.</p> <p>This means that even if the authentication cookie is still valid, the <code>access_token</code> and <code>refresh_token</code> may expire. In such cases, the user will appear authenticated in the UI, but API calls to downstream services will begin to fail with <code>401 Unauthorized</code> errors.</p> <p>If you don\u2019t proactively validate or refresh these tokens, you risk users having an active session in the UI but losing access to key functionality that depends on secured API calls.</p> <p>Guideline for two types of application architectures where authentication is handled on the server: </p> <ul> <li>Angular with a BFF</li> <li>Blazor with Interactive Server</li> </ul> <p></p>"},{"location":"developer-guideline/TokenExpiration/AuthenticationWithAngularBFF/","title":"Token Expiry Handling with Angular BFF Client and Downstream APIs","text":""},{"location":"developer-guideline/TokenExpiration/AuthenticationWithAngularBFF/#problem","title":"Problem","text":"<p>When the <code>access_token</code> and <code>refresh_token</code> expire, but the authentication cookie is still valid, the user will appear authenticated, yet calls to downstream APIs will start to fail with <code>401 Unauthorized</code>.</p>"},{"location":"developer-guideline/TokenExpiration/AuthenticationWithAngularBFF/#alternative-solutions","title":"Alternative solutions","text":"<p>To avoid this mismatch there are several possible solutions: </p> <ul> <li>Use CookieEvent to validate the refresh token: To ensure the session remains valid from the API\u2019s perspective, proactively validate the refresh_token.</li> <li>Implement a global exception handler for downstream API errors: Set up a global exception handler to capture exceptions from downstream APIs. Specifically, handle 401 responses by throwing a 401 exception, which can then be handled appropriately by the client.</li> <li>Create custom middleware for token management: Develop middleware that checks the token\u2019s expiration before forwarding requests to downstream APIs. If the token has expired, refresh it automatically before proceeding.</li> </ul>"},{"location":"developer-guideline/TokenExpiration/AuthenticationWithAngularBFF/#solution-use-cookieevent-to-validate-the-refresh-token","title":"Solution - Use CookieEvent to validate the refresh token","text":"<p>Override the <code>ValidatePrincipal</code> method and check the status of both the <code>access_token</code> and <code>refresh_token</code>. If the <code>access_token</code> is expired, attempt to use the <code>refresh_token</code> to obtain a new one. If that fails, reject the principal.</p> <p>\ud83d\udd12 This logic must be combined with proper cookie expiration settings using <code>ExpireTimeSpan</code> to manage session longevity consistently.</p> <pre><code>flowchart TD\n    A[User makes request] --&gt; B[Cookie is valid?]\n    B -- No --&gt; X[Reject request]\n    B -- Yes --&gt; C[Is user authenticated?]\n    C -- No --&gt; X\n    C -- Yes --&gt; D[Get access_token and refresh_token from cookie]\n    D --&gt; E[Are tokens missing or empty?]\n    E -- Yes --&gt; R1[RejectPrincipal and Renew]\n    E -- No --&gt; F[Check if access_token is expired]\n    F -- No --&gt; Z[Proceed with request]\n    F -- Yes --&gt; G[Attempt to refresh access_token using refresh_token]\n    G --&gt; H[Was refresh successful?]\n    H -- No --&gt; R2[RejectPrincipal &amp; Renew]\n    H -- Yes --&gt; Z\n\n</code></pre>"},{"location":"developer-guideline/TokenExpiration/AuthenticationWithAngularBFF/#example-implementation","title":"Example Implementation","text":"<pre><code>public override async Task ValidatePrincipal(CookieValidatePrincipalContext context)\n{\n    if (context.Principal?.Identity is not null &amp;&amp; context.Principal.Identity.IsAuthenticated)\n    {\n        var tokens = context.Properties.GetTokens();\n        var accessToken = tokens.SingleOrDefault(t =&gt; t.Name == OpenIdConnectParameterNames.AccessToken);\n        var refreshToken = tokens.SingleOrDefault(t =&gt; t.Name == OpenIdConnectParameterNames.RefreshToken);\n\n        if (accessToken == null || string.IsNullOrEmpty(accessToken.Value) ||\n            refreshToken == null || string.IsNullOrEmpty(refreshToken.Value))\n        {\n            context.RejectPrincipal();\n            context.ShouldRenew = true;\n            return;\n        }\n\n        var expiresAt = DateTimeOffset.Parse(\n            tokens.SingleOrDefault(t =&gt; t.Name == \"expires_at\")?.Value ?? string.Empty,\n            CultureInfo.InvariantCulture);\n\n        if (expiresAt &lt;= DateTimeOffset.UtcNow)\n        {\n            var refreshedTokens = await _userTokenEndpointService.RefreshAccessTokenAsync(\n                new UserToken\n                {\n                    RefreshToken = refreshToken.Value\n                },\n                new UserTokenRequestParameters());\n\n            if (refreshedTokens.IsError)\n            {\n                context.RejectPrincipal();\n                context.ShouldRenew = true;\n                return;\n            }\n        }\n    }\n\n    await base.ValidatePrincipal(context);\n}\n</code></pre>"},{"location":"developer-guideline/TokenExpiration/AuthenticationWithAngularBFF/#solution-implement-a-global-exception-handler-for-downstream-api-errors","title":"Solution - Implement a global exception handler for downstream API errors","text":"<p>``` public class TokenExpirationMiddleware {     private readonly RequestDelegate _next;</p> <pre><code>public TokenExpirationMiddleware(RequestDelegate next) =&gt; _next = next;\n\npublic async Task InvokeAsync(HttpContext context)\n{\n    var user = context.User;\n    if (user.Identity is not null &amp;&amp; user.Identity.IsAuthenticated)\n    {\n        var userToken = await context.GetUserAccessTokenAsync();\n        if (userToken.IsError)\n        {\n            //Handle token expiration in your application in your preffered way\n            //await context.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme);\n        }\n    }\n\n    await _next(context);\n}\n</code></pre> <p>}</p> <p>```csharp</p>"},{"location":"developer-guideline/TokenExpiration/AuthenticationWithBlazorServer/","title":"Token Expiry Handling with Blazor server client and Downstream APIs","text":""},{"location":"developer-guideline/TokenExpiration/AuthenticationWithBlazorServer/#problem","title":"Problem","text":"<p>In Blazor Server, communication between the browser (client) and the server is managed through SignalR, which maintains a persistent connection using WebSockets (or fallback mechanisms). Blazor Server uses SignalR for all UI interactions and event handling. The SignalR connection does not have access to HttpContext or cookies directly. When a client establishes a connection to the SignalR server it creates <code>HubCallerContext</code> with ConnectionId, User (Claimsprincipal) and Items (properties). </p> <p>Unlike traditional HTTP requests where cookies are sent with each request, SignalR only sends cookies once, during the initial connection (handshake). After that, no HTTP headers are included in individual method calls over SignalR.</p> <p>As a result:</p> <ul> <li>You cannot access HttpContext.Request.Cookies from inside Blazor components.</li> <li>You lose access to cookies during the lifetime of the SignalR connection.</li> <li>HubCallerContext.User is not updated when the authentication cookie is renewed.</li> </ul> <p>Blazor state management Blazor Server side authentication</p> <p>|Scenario | Available in Blazor Server? | Recommendation| |-----|------------------|------------------|---------| |HttpContext.Request.Cookies | No | Can be used in a API Controller| |AuthenticationStateProvider / User | Yes | Reads the claimssprincipal from HubCallerContext| |ProtectedSessionStorage |  Only after OnAfterRender | Unng\u00e5 for auth-flow |HttpContext.GetTokenAsync(...) |No | Use in middleware or controllers| |Controller + HttpClient | Yes | Best solution to get tokens|</p>"},{"location":"developer-guideline/TokenExpiration/AuthenticationWithBlazorServer/#alternative-solution","title":"Alternative solution","text":""},{"location":"developer-guideline/TokenExpiration/AuthenticationWithBlazorServer/#listen-on-401-from-downstream-api-and-redirect-to-login-site-with-full-reload","title":"Listen on 401 from downstream API and redirect to login site with full reload","text":"<pre><code>\nsequenceDiagram\n    participant Browser as Blazor (Browser)\n    participant SignalR as SignalR Hub (Blazor Server)\n    participant API as API Backend\n    participant Auth as IdentityServer (Duende)\n\n    Browser-&gt;&gt;SignalR: Establish connection (via WebSocket)\n    SignalR--&gt;&gt;Browser: Connected\n\n    Browser-&gt;&gt;API: HTTP Request (e.g., GET /data)\n    API--&gt;&gt;Browser: JSON response\n\n    Note over Browser: Auth cookie may expire...\n\n    Browser-&gt;&gt;API: Another request (after auth expired)\n    API--&gt;&gt;Browser: Redirect to IdentityServer\n\n    Browser-&gt;&gt;Auth: OpenID Connect login redirect\n    Auth--&gt;&gt;Browser: Token/Cookie issued, redirected back\n\n    Browser-&gt;&gt;SignalR: Reconnect\n    SignalR--&gt;&gt;Browser: Reconnected\n\n</code></pre>"}]}