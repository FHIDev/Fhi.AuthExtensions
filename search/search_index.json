{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Sample and guideline of how to do authentication and authorization in FHI. The code and samples is built on top of Duende open source project and Microsoft authentication libraries</p> <p>Note: Sample code is not production code. The code should be customized to fit the need of the application.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Check out guide and samples to see how to:</p> <ul> <li>Token Expiry Handling with Downstream APIs</li> <li>Require authentication by default in .NET Core</li> </ul> <p>Also checkout learning and samples from Duende. </p>"},{"location":"concepts/","title":"Concepts and terminology","text":"<ul> <li>HelseID</li> <li>ID Porten</li> <li>Terminology</li> <li>Authentication concepts</li> </ul>"},{"location":"packages/","title":"Overview of packages","text":""},{"location":"packages/#fhi-packages","title":"FHI packages","text":"Package Purpose Releases Fhi.Authentication.Extensions Extension to authentication Releases Fhi.Authorization.Extensions Extensions to authorization and access control Releases"},{"location":"packages/#duende-opensource-packages","title":"Duende opensource packages","text":"<p>Duende Free and Open Source Software</p>"},{"location":"packages/#microsoft-packages","title":"Microsoft Packages","text":"Package Purpose Microsoft.AspNetCore.Authentication.OpenIdConnect Library for authenticationg end-user with OpenID Connect Microsoft.AspNetCore.Authentication.JwtBearer Library for validating a Jwt Bearer token"},{"location":"developer-guideline/protecting-endpoints/","title":"Require authentication by default in .NET Core","text":"<p>To require authentication by default on all incoming requests, configure a fallback authorization policy in your application's service pipeline. The policy will automatically require users to be authenticated for all endpoints unless explicitly overridden to allow anonymous access. This approach reduces the risk of accidentally exposing sensitive endpoints.</p> <p>Code samples:</p> <ul> <li>Angular BFF sample</li> <li>Web Api</li> </ul>"},{"location":"developer-guideline/protecting-endpoints/#1-add-the-fallback-policy","title":"1: Add the fallback policy","text":"<p>All controllers and endpoints require an authenticated user. If a request is made to any endpoint and the user is not authenticated, a 401 Unauthorized response is returned. This is achieved using the <code>SetFallbackPolicy</code> method or <code>FallbackPolicy</code> option in the authorization configuration:</p> <pre><code>// Option 1: by default\nbuilder.Services.AddAuthorizationBuilder()\n    .SetFallbackPolicy(new AuthorizationPolicyBuilder()\n        .RequireAuthenticatedUser()\n        .Build());\n\n// Or option 2:\nbuilder.Services.AddAuthorization(options =&gt;\n{\n    options.FallbackPolicy = new AuthorizationPolicyBuilder()\n                .RequireAuthenticatedUser()\n                .Build();\n\n// Or option 3: for multiple authentication schemes\nbuilder.Services.AddAuthorizationBuilder()\n                .SetFallbackPolicy(new AuthorizationPolicyBuilder()\n                            .RequireAuthenticatedUser()\n                            .Build())\n                .AddPolicy(\"Scheme1\", policy =&gt;\n                {\n                    policy.AuthenticationSchemes.Add(\"Scheme1\");\n                    policy.RequireAuthenticatedUser();\n                })\n                 .AddPolicy(\"Scheme2\", policy =&gt;\n                 {\n                     policy.AuthenticationSchemes.Add(\"Scheme2\");\n                     policy.RequireAuthenticatedUser();\n                 });\n\n});\n</code></pre>"},{"location":"developer-guideline/protecting-endpoints/#2-permit-anonymous-access","title":"2: Permit anonymous access","text":"<p>To allow anonymous access to specific endpoints (such as /login, /session, or the SPA fallback) use <code>[AllowAnonymous]</code> or <code>AllowAnonymous()</code> attribute on specific endpoints to permit anonymous access.</p> <pre><code>// This endpoint allows anonymous access\napp.MapGet(\"/login\", [AllowAnonymous] async (HttpContext context) =&gt; { ... });\n\n// For an SPA client like Angular should allow anonymous access to the index page\napp.MapFallbackToFile(\"/index.html\").AllowAnonymous();\n</code></pre>"},{"location":"developer-guideline/token-expiry-downstream-api/","title":"Token Expiry Handling with Downstream APIs","text":"<p>Applications that handle authentication on the server using cookies and OpenID Connect (OIDC), and that need to call downstream APIs with <code>access_token</code> must be aware of that cookies and tokens have separate lifetimes.</p> <p>This means that even if the authentication cookie is still valid, the <code>access_token</code> and <code>refresh_token</code> may expire. In such cases, the user will appear authenticated in the UI, but API calls to downstream services will begin to fail with <code>401 Unauthorized</code> errors.</p> <p>If you don\u2019t proactively validate or refresh these tokens, you risk users having an active session in the UI but losing access to key functionality that depends on secured API calls.</p> <p>Guideline for two types of application architectures where authentication is handled on the server: </p> <ul> <li>Angular with a BFF</li> <li>Blazor with Interactive Server</li> </ul> <p></p>"},{"location":"developer-guideline/TokenExpiration/AuthenticationWithAngularBFF/","title":"Token expiration handling with Angular BFF Client and Downstream APIs","text":""},{"location":"developer-guideline/TokenExpiration/AuthenticationWithAngularBFF/#problem","title":"Problem","text":"<p>When the <code>access_token</code> and <code>refresh_token</code> expire, but the authentication cookie is still valid, the user will appear authenticated, yet calls to downstream APIs will start to fail with <code>401 Unauthorized</code>. See React to back-end changes</p>"},{"location":"developer-guideline/TokenExpiration/AuthenticationWithAngularBFF/#alternative-solutions","title":"Alternative solutions","text":"<p>To avoid this mismatch there are several possible solutions: </p> <ul> <li>Use CookieEvent to validate the refresh token: To ensure the session remains valid from the API\u2019s perspective, proactively validate the refresh_token.</li> <li>Implement a global exception handler for downstream API errors: Set up a global exception handler to capture exceptions from downstream APIs. Specifically, handle 401 responses by throwing a 401 exception, which can then be handled appropriately by the client.</li> <li>Create custom middleware for token management: Develop middleware that checks the token\u2019s expiration before forwarding requests to downstream APIs. If the token has expired, refresh it automatically before proceeding.</li> </ul>"},{"location":"developer-guideline/TokenExpiration/AuthenticationWithAngularBFF/#use-cookieevent-to-validate-the-refresh-token","title":"Use CookieEvent to validate the refresh token","text":"<p>Override the <code>ValidatePrincipal</code> method on the CookieEvent and check the status of both the <code>access_token</code> and <code>refresh_token</code>. If the <code>access_token</code> is expired, attempt to use the <code>refresh_token</code> to obtain a new one. If that fails, reject the principal.</p> <p>\ud83d\udd12 This logic must be combined with proper cookie expiration settings using <code>ExpireTimeSpan</code> to manage session longevity consistently.</p> <p>See sample code in Angular and Blazor</p> <p>Do the following steps:</p>"},{"location":"developer-guideline/TokenExpiration/AuthenticationWithAngularBFF/#step-1-change-cookie-expiration-time","title":"Step 1: Change Cookie expiration time","text":"<p>ExpireTimeSpan should be set out from access_token and refresh_token lifetime. This is to ensure that the cookie is not expired after the refresh token is expired. </p> <p>Sample code <pre><code>builder.Services.AddAuthentication(options =&gt;\n{\n    options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;\n    options.DefaultChallengeScheme = OpenIdConnectDefaults.AuthenticationScheme;\n}).AddCookie(options =&gt;\n{\n    options.ExpireTimeSpan = TimeSpan.FromSeconds(90);\n})\n...\n</code></pre></p>"},{"location":"developer-guideline/TokenExpiration/AuthenticationWithAngularBFF/#step-2-add-addopenidconnectcookieoptions-to-the-pipeline","title":"Step 2: Add AddOpenIdConnectCookieOptions to the pipeline","text":"<p>You can use <code>Fhi.Authentication.Extensions</code> package to validate the token expiration.</p> <p>The <code>AddOpenIdConnectCookieOptions</code> will add <code>ValidatePrincipal</code> event that checks if token is expired, see implementation and handle <code>SignOut</code> OpenIdConnectCookieEventsForApi</p> <pre><code>builder.Services.AddOpenIdConnectCookieOptions();\n</code></pre>"},{"location":"developer-guideline/TokenExpiration/AuthenticationWithAngularBFF/#create-custom-middleware-for-token-management","title":"Create custom middleware for token management","text":"<p>The sample below uses Duende accesstoken management <code>GetUserAccessTokenAsync</code> extension</p> <pre><code>public class TokenExpirationMiddleware\n{\n    private readonly RequestDelegate _next;\n\n    public TokenExpirationMiddleware(RequestDelegate next) =&gt; _next = next;\n\n    public async Task InvokeAsync(HttpContext context)\n    {\n        var user = context.User;\n        if (user.Identity is not null &amp;&amp; user.Identity.IsAuthenticated)\n        {\n            var userToken = await context.GetUserAccessTokenAsync();\n            if (userToken.IsError)\n            {\n                //Handle token expiration in your application in your preffered way\n                //await context.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme);\n            }\n        }\n\n        await _next(context);\n    }\n}\n</code></pre>"},{"location":"developer-guideline/TokenExpiration/AuthenticationWithBlazorServer/","title":"Token Expiry Handling with Blazor server client and Downstream APIs","text":""},{"location":"developer-guideline/TokenExpiration/AuthenticationWithBlazorServer/#problem","title":"Problem","text":"<p>In Blazor Server, communication between the browser (client) and the server is managed through SignalR, which maintains a persistent connection using WebSockets (or fallback mechanisms). Blazor Server uses SignalR for all UI interactions and event handling. The SignalR connection does not have access to HttpContext or cookies directly. When a client establishes a connection to the SignalR server it creates <code>HubCallerContext</code> with ConnectionId, User (Claimsprincipal) and Items (properties). </p> <p>Unlike traditional HTTP requests where cookies are sent with each request, SignalR only sends cookies once, during the initial connection (handshake). After that, no HTTP headers are included in individual method calls over SignalR.</p> <p>As a result:</p> <ul> <li>You cannot access HttpContext.Request.Cookies from inside Blazor components.</li> <li>You lose access to cookies during the lifetime of the SignalR connection.</li> <li>HubCallerContext.User is not updated when the authentication cookie is renewed.</li> </ul> <p>See Blazor state management Blazor Server side authentication</p>"},{"location":"developer-guideline/TokenExpiration/AuthenticationWithBlazorServer/#alternative-solution","title":"Alternative solution","text":""},{"location":"developer-guideline/TokenExpiration/AuthenticationWithBlazorServer/#listen-on-401-from-downstream-api-and-redirect-to-login-site-with-full-reload","title":"Listen on 401 from downstream API and redirect to login site with full reload","text":"<pre><code>\nsequenceDiagram\n    participant Browser as Blazor (Browser)\n    participant SignalR as SignalR Hub (Blazor Server)\n    participant API as API Backend\n    participant Auth as IdentityServer (Duende)\n\n    Browser-&gt;&gt;SignalR: Establish connection (via WebSocket)\n    SignalR--&gt;&gt;Browser: Connected\n\n    Browser-&gt;&gt;API: HTTP Request (e.g., GET /data)\n    API--&gt;&gt;Browser: JSON response\n\n    Note over Browser: Auth cookie may expire...\n\n    Browser-&gt;&gt;API: Another request (after auth expired)\n    API--&gt;&gt;Browser: Redirect to IdentityServer\n\n    Browser-&gt;&gt;Auth: OpenID Connect login redirect\n    Auth--&gt;&gt;Browser: Token/Cookie issued, redirected back\n\n    Browser-&gt;&gt;SignalR: Reconnect\n    SignalR--&gt;&gt;Browser: Reconnected\n</code></pre>"}]}